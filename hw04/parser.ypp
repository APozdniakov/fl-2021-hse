%{
#include <cstddef>
#include <fstream>
#include <iostream>
#include <set>
#include <sstream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

void yyerror(const char *);

class Automata {
  std::size_t alphabet_size, states_quantity;
  std::unordered_set<char> alphabet;
  std::vector<std::unordered_map<char, int>> graph;
  std::vector<bool> terminal;
  std::size_t start;

  std::vector<std::size_t> cur_adj_states;
  std::vector<char> cur_edge_symbols;

  void check_symbol(char c) {
    if (alphabet.find(c) == alphabet.end()) {
      std::stringstream ss;
      ss << "Symbol \"" << c << "\" is not in the alphabet";
      yyerror(ss.str().c_str());
    }
  }
  void check_state(std::size_t state) {
    if (!(0 <= state && state < states_quantity)) {
      std::stringstream ss;
      ss << "State " << state << " doesn't exist";
      yyerror(ss.str().c_str());
    }
  }
  void check_size(std::size_t size) {
    if (size == 0) {
      yyerror("Size can't be 0");
    }
  }

public:
  void set_alphabet_size(std::size_t size) {
    check_size(size);
    alphabet_size = size;
    alphabet.reserve(size);
  }
  void add_alphabet_symbol(char c) {
    if (alphabet.find(c) != alphabet.end()) {
      std::stringstream ss;
      ss << "Symbol \"" << c << "\" is already in the alphabet";
      yyerror(ss.str().c_str());
    }
    alphabet.insert(c);
  }
  void set_states_quantity(std::size_t size) {
    check_size(size);
    states_quantity = size;
    graph.reserve(size);
    terminal.reserve(size);
  }
  void set_state_info(std::size_t size, bool is_terminal) {
    check_size(size);
    if (size != alphabet.size()) {
      yyerror("Automata isn't complete");
    }
    std::vector<std::size_t>().swap(cur_adj_states);
    cur_adj_states.reserve(size);
    std::vector<char>().swap(cur_edge_symbols);
    cur_edge_symbols.reserve(size);
    terminal.push_back(is_terminal);
  }
  void add_adjacent_state(std::size_t state) {
    check_state(state);
    if (cur_adj_states.size() == cur_adj_states.capacity()) {
      std::stringstream ss;
      ss << "Too many adjacent states for state " << graph.size();
      yyerror(ss.str().c_str());
    }
    cur_adj_states.push_back(state);
  }
  void add_edge_symbol(char c) {
    check_symbol(c);
    if (cur_edge_symbols.size() == cur_edge_symbols.capacity()) {
      std::stringstream ss;
      ss << "Too many edge symbols for state " << graph.size();
      yyerror(ss.str().c_str());
    }
    cur_edge_symbols.push_back(c);
  }
  void add_all_edges() {
    if (cur_adj_states.size() < cur_adj_states.capacity()) {
      std::stringstream ss;
      ss << "Not enough adjacent states for state " << graph.size();
      yyerror(ss.str().c_str());
    }
    if (cur_edge_symbols.size() < cur_edge_symbols.capacity()) {
      std::stringstream ss;
      ss << "Not enough edge symbols for state " << graph.size();
      yyerror(ss.str().c_str());
    }
    if (std::set<char> unique_symbols(cur_edge_symbols.begin(), cur_edge_symbols.end());
        unique_symbols.size() != cur_edge_symbols.size()) {
      yyerror("Automata is non-deterministic");
    }
    graph.emplace_back();
    for (int i = 0; i < cur_adj_states.size(); ++i) {
      graph.back()[cur_edge_symbols[i]] = cur_adj_states[i];
    }
  }
  void set_start_state(std::size_t state) {
    check_state(state);
    start = state;
  }
  bool match(const std::string &s) {
    std::size_t state = start;
    for (char c : s) {
      check_symbol(c);
      check_state(state);
      if (graph[state].find(c) == graph[state].end()) {
        return false;
      }
      state = graph[state][c];
    }
    return terminal[state];
  }
} automata;

int yylex();
void yyerror(const char *msg) {
  std::cout << msg << '\n';
  exit(1);
}
%}

%union {
  int val;
  char symb;
  char *str;
};
%token<val> T_NUMBER
%token<str> T_KEYWORD
%token<symb> T_SYMBOL T_END_LINE

%%
start
  : ALPHABET_SIZE ALPHABET STATES_QUANTITY parse_state_info {}

parse_state_info
  : STATE_INFO parse_state_info {}
  | START_STATE {}

ALPHABET_SIZE : T_NUMBER T_END_LINE {
  automata.set_alphabet_size($1);
}

ALPHABET
  : T_SYMBOL ALPHABET {
    automata.add_alphabet_symbol($1);
  }
  | T_SYMBOL T_END_LINE {
    automata.add_alphabet_symbol($1);
  }

STATES_QUANTITY
  : T_NUMBER T_END_LINE {
    automata.set_states_quantity($1);
  }

STATE_INFO
  : STATE_HEADER ADJACENT_STATES EDGE_SYMBOLS {
    automata.add_all_edges();
  }

STATE_HEADER
  : T_NUMBER T_END_LINE {
    automata.set_state_info($1, false);
  }
  | T_KEYWORD T_NUMBER T_END_LINE {
    automata.set_state_info($2, true);
  }

ADJACENT_STATES
  : T_NUMBER ADJACENT_STATES {
    automata.add_adjacent_state($1);
  }
  | T_NUMBER T_END_LINE {
    automata.add_adjacent_state($1);
  }

EDGE_SYMBOLS
  : T_SYMBOL EDGE_SYMBOLS {
    automata.add_edge_symbol($1);
  }
  | T_SYMBOL T_END_LINE {
    automata.add_edge_symbol($1);
  }

START_STATE
  : T_NUMBER {
    automata.set_start_state($1);
  }
%%

int main(int argc, char *argv[]) {
  yyparse();

  std::ifstream ifs(argv[1]);
  std::string str;
  ifs >> str;
  std::cout << std::boolalpha << automata.match(str) << '\n';
}
