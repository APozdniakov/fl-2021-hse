%{
#include <cstddef>
#include <exception>
#include <fstream>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

struct Automata {
  std::size_t alphabet_size, states_quantity;
  std::unordered_set<char> alphabet;
  std::vector<std::unordered_map<char, int>> graph;
  std::vector<bool> terminal;
  std::size_t start;

  std::vector<std::size_t> cur_adj_states;
  std::vector<char> cur_edge_symbols;

  bool check_symbol(char c) {
    return alphabet.find(c) != alphabet.end();
  }
  bool check_state(std::size_t state) {
    return 0 <= state && state < states_quantity;
  }
  void add_all_edges() {
    if (cur_adj_states.size() != cur_adj_states.capacity()) {}
    graph.emplace_back();
    for (int i = 0; i < cur_adj_states.size(); ++i) {
      graph.back()[cur_edge_symbols[i]] = cur_adj_states[i];
    }
  }

public:
  void set_alphabet_size(std::size_t size) {
//    std::cout << "alphabet size " << size << '\n';
    if (size == 0) {}
    alphabet_size = size;
    alphabet.reserve(size);
  }
  void add_alphabet_symbol(char c) {
//    std::cout << "alphabet symbol " << c << '\n';
    if (alphabet.find(c) != alphabet.end()) {}
    alphabet.insert(c);
  }
  void set_states_quantity(std::size_t size) {
//    std::cout << "number of states: " << size << '\n';
    if (size == 0) {}
    states_quantity = size;
    graph.reserve(size);
    terminal.reserve(size);
  }
  void set_state_info(std::size_t size, bool is_terminal) {
//    std::cout << size << " edges to other states";
//    if (is_terminal) std::cout << " && TERMINAL";
//    std::cout << '\n';
    cur_adj_states.clear();
    cur_adj_states.reserve(size);
    cur_edge_symbols.clear();
    cur_edge_symbols.reserve(size);
    terminal.push_back(is_terminal);
  }
  void add_adjacent_state(std::size_t state) {
//    std::cout << "add edge to " << state << '\n';
    if (!check_state(state)) {}
    if (cur_adj_states.size() == cur_adj_states.capacity()) {}
    cur_adj_states.push_back(state);
  }
  void add_edge_symbol(char c) {
//    std::cout << c << " on edge\n";
    if (!check_symbol(c)) {}
    if (cur_edge_symbols.size() == cur_edge_symbols.capacity()) {}
    cur_edge_symbols.push_back(c);
    if (cur_edge_symbols.size() == cur_edge_symbols.capacity()) {
      add_all_edges();
    }
  }
  void set_start_state(std::size_t state) {
//    std::cout << "initial state: " << state << "\n";
    if (!check_state(state)) {}
    start = state;
  }
  bool match(const std::string &s) {
    std::size_t state = start;
    for (char c : s) {
      std::cout << state << ' ' << c << '\n';
      if (graph[state].find(c) == graph[state].end()) {
        return false;
      }
      state = graph[state][c];
    }
    return true;
  }
} automata;

int yylex();
void yyerror(const char *) { std::cout << "Error" << std::endl; }
%}

%union {
  int val;
  char symb;
  char *str;
};
%token<val> T_NUMBER
%token<str> T_KEYWORD
%token<symb> T_SYMBOL T_END_LINE

%type<val> ALPHABET_SIZE ALPHABET_SYMBOL STATES_QUANTITY STATE_INFO ADJACENT_STATE EDGE_SYMBOL START_STATE

%%
start
  : parse_alphabet_size {}

parse_alphabet_size
  : ALPHABET_SIZE T_END_LINE parse_alphabet {}

parse_alphabet
  : ALPHABET_SYMBOL parse_alphabet {}
  | ALPHABET_SYMBOL T_END_LINE parse_states_quantity {}

parse_states_quantity
  : STATES_QUANTITY T_END_LINE parse_state_info {}

parse_state_info
  : STATE_INFO T_END_LINE parse_adjacent_states {}
  | parse_start_state {}

parse_adjacent_states
  : ADJACENT_STATE parse_adjacent_states {}
  | ADJACENT_STATE T_END_LINE parse_symbols_on_edges {}

parse_symbols_on_edges
  : EDGE_SYMBOL parse_symbols_on_edges {}
  | EDGE_SYMBOL T_END_LINE parse_state_info {}

parse_start_state : START_STATE {}

ALPHABET_SIZE : T_NUMBER {
  automata.set_alphabet_size($1);
}

ALPHABET_SYMBOL : T_SYMBOL {
  automata.add_alphabet_symbol($1);
}

STATES_QUANTITY : T_NUMBER {
  automata.set_states_quantity($1);
}

STATE_INFO
  : T_NUMBER {
    automata.set_state_info($1, false);
  }
  | T_KEYWORD T_NUMBER {
    automata.set_state_info($2, true);
  }

ADJACENT_STATE : T_NUMBER {
  automata.add_adjacent_state($1);
}

EDGE_SYMBOL : T_SYMBOL {
  automata.add_edge_symbol($1);
}

START_STATE : T_NUMBER {
  automata.set_start_state($1);
}
%%

int main(int argc, char *argv[]) {
  yyparse();

  std::ifstream ifs(argv[1]);
  std::string str;
  ifs >> str;
  std::cout << std::boolalpha << automata.match(str) << '\n';
}